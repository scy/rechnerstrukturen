<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8" />
	<title>Rechnerstrukturen – MMK13</title>
	<link rel="stylesheet" href="scylec/scylec-2013.css" />
	<script src="scylec/jquery-1.10.2.min.js"></script>
	<script src="scylec/scylec.js"></script>
	<script>
		scylec.onReady(function () {
			scylec.doPresentation();
		});
	</script>
</head>

<body class="scylec-mode-script">

<h1>Rechnerstrukturen</h1>

<p>
Dieses Dokument enthält sowohl die Folien der Vorlesung ›Rechnerstrukturen‹ als auch weiterführende, erklärende Texte.
</p>

<h2>Organisatorisches</h2>

<p>
Bevor es an den eigentlichen Inhalt der Vorlesung geht, gehört es sich, dass ich als Dozent mich erst mal vorstelle.
Außerdem habe ich ein paar organisatorische Informationen zum Ablauf für Sie.
</p>

<article class="slide"><h3>Über den Dozenten</h3>
<ul>
	<li>Tim Weber <code class="email"><a href="mailto:dhbw@timweber.name">dhbw@timweber.name</a></code></li>
	<li>angestellt als Webentwickler bei der <a href="http://www.cocomore.de/">Cocomore AG</a></li>
	<li>studierte Software- und Internettechnologie an der Uni Mannheim</li>
	<li>arbeitete als Systemadministrator am Uni-Rechenzentrum</li>
	<li>betriebssystem- und hardwarenahe Programmiererfahrung</li>
	<li>Nerd und Netzaktivist</li>
</ul>
</article>

<p>
Mein Name ist Tim Weber, Jahrgang 1983, geboren und aufgewachsen in Mannheim, aber inzwischen wohne und arbeite ich in Frankfurt.
Meine Dozententätigkeit an der DHBW habe ich 2011 aufgenommen.
Damals habe ich noch in Mannheim gewohnt, und trotz meines Umzugs nach Frankfurt unterrichte ich hier weiter.
Da ich mit meinem Arbeitgeber, der <a href="http://www.cocomore.de/">Cocomore AG</a> eine Vier-Tage-Woche vereinbart habe, arbeite ich montags nicht und habe daher Zeit für Vorlesungen.
</p>

<article class="slide"><h3>Termine</h3>
<ul>
	<li>7 Termine à 3:45 h</li>
	<li>jeweils Montag 10:30–15:00, vom 07.10. bis 18.11.</li>
	<li>Vorschlag: 10:30–12:30 (2:00 h), 45 min Pause, 13:15–15:00 (1:45 h)</li>
	<li>Klausurzeit 16.–23.12.</li>
	<li>Klausurblock „Multimedia-Grundlagen I“, 180 min</li>
	<li>davon 55 min Rechnerstrukturen</li>
</ul>
<aside><ul>
	<li>alt. 10:30–12:00 (1:30 h), 45 min Pause, 12:45–15:00 (2:15 h)</li>
	<li>alt. 10:30–12:15 (1:45 h), 45 min Pause, 13:00–15:00 (2:00 h)</li>
	<li>alt. 10:30–12:00 (1:30 h), 30 min Pause, 12:30–13:45 (1:15 h), 15 min Pause, 14:00–15:00 (1:00 h)</li>
</ul></aside>
</article>

<p>
Da ich nur montags Zeit habe, müssen die 36x 45 Minuten in sieben relativ lange Blöcke aufgeteilt werden.
</p>

<article class="slide"><h3>Gliederung</h3>
<ul>
	<li>allgemeine Rechnerarchitektur</li>
	<li>Daten und deren Repräsentation</li>
	<li>Speichertechnologien, Massenspeicher</li>
	<li>Schnittstellen und Bussysteme</li>
	<li>Ethernet</li>
	<li>Funktechnologien</li>
	<li>Cloud Computing, Wiederholung</li>
</ul>
</article>

<article class="slide"><h3>Ablauf</h3>
<ul>
	<li>Anwesenheitsliste</li>
	<li>Fragen jederzeit</li>
	<li>bitte möglichst am Anfang oder <em>während</em> der Vorlesung, nicht danach</li>
	<li>Rückfragen per Mail oder (besser!) auf Facebook/G+<ul>
		<li>was nehmen wir?</li>
	</ul></li>
	<li>Folien/Skriptum entstehen während des Semesters</li>
	<li>Link und Druckversion ab nächster Woche</li>
	<li>viele weiterführende (Wikipedia-)Links</li>
</ul>
</article>

<article class="slide"><h3>Ein paar Worte zum ersten Semester</h3>
<ul>
	<li>dies ist eine Hochschule, Sie sind hier freiwillig</li>
	<li>Fragen an mich oder alle: gern</li>
	<li>Unterhaltungen untereinander: ungern</li>
	<li>ich diktiere nichts, machen Sie sich eigenständig Notizen<ul>
		<li>die Tafel mitzuschreiben ist womöglich klug</li>
	</ul></li>
	<li>Laptop, Telefon etc.: finden Sie raus, ob Sie gleichzeitig tumblern können und der Vorlesung folgen<ul>
		<li>wenn nicht, lassen Sie eins von beidem bleiben</li>
	</ul></li>
	<li>lernen Sie <em>während</em> des Semesters, sonst ist es zu viel</li>
</ul>
</article>

<article class="slide"><h3>Ziel der Vorlesung</h3>
<ul>
	<li>worum geht es <em>Ihnen</em>?</li>
</ul>
</article>

<h2>Allgemeine Rechnerarchitektur</h2>

<article class="slide"><h3>Was ist ein Computer?</h3>
<blockquote>
	<p>Ein Computer oder Rechner ist ein Gerät, das mittels programmierbarer Rechenvorschriften Daten verarbeitet.</p>
	<p><cite><a href="http://de.wikipedia.org/w/index.php?title=Computer&amp;oldid=123034903">Wikipedia: Computer</a></p>
</blockquote>
</article>

<article class="slide"><h3>Beispiele für Computer</h3>
<ul>
	<li>PC, Mac</li>
	<li>iPad</li>
	<li>PlayStation</li>
	<li>Mobiltelefon</li>
	<li>Mikrocontroller</li>
	<li>Waschmaschine</li>
	<li>…</li>
</ul>
</article>

<article class="slide"><h3>Geschichte des Computers</h3>
<ul>
	<li>17. Jh.: erste <a href="http://de.wikipedia.org/w/index.php?title=Vier-Spezies-Maschine&amp;oldid=98123162">Vier-Spezies-Maschinen</a>, z.B. die <a href="http://de.wikipedia.org/w/index.php?title=Pascaline&amp;oldid=116771797">Pascaline</a><ul>
		<li>Beispiel aus den 1940er Jahren: <a href="http://de.wikipedia.org/w/index.php?title=Curta&amp;oldid=120867847">Curta</a> (<a href="http://www.youtube.com/watch?v=HYsOi6L_Pw4">Demo-Video</a>)</li>
	</ul></li>
	<li>1940er: <a href="http://de.wikipedia.org/w/index.php?title=Zuse_Z3&amp;oldid=121577423">Zuse Z3</a>, <a href="http://de.wikipedia.org/w/index.php?title=ENIAC&amp;oldid=122274199">ENIAC</a></li>
	<li>1960er/1970er: <a href="http://en.wikipedia.org/w/index.php?title=The_Mother_of_All_Demos&amp;oldid=575790443">The Mother of All Demos</a> (Maus, Hypertext, kollaborativer Echtzeiteditor), <a href="http://de.wikipedia.org/w/index.php?title=Xerox_Alto&amp;oldid=116884085">Xerox Alto</a> (erstes GUI)</li>
	<li>1980er: <a href="http://de.wikipedia.org/w/index.php?title=Commodore_64&amp;oldid=122750327">Commodore 64</a> (Heimcomputer), <a href="http://de.wikipedia.org/w/index.php?title=Microsoft_Windows&amp;oldid=122790671">Windows</a></li>
</ul>
</article>

<article class="slide"><h3>Aufbau eines heutigen Computers</h3>
<ul>
	<li>laut <a href="http://de.wikipedia.org/w/index.php?title=Personal_Computer&amp;oldid=122899149">Wikipedia</a> u.a. Hauptplatine, Hauptprozessor, Arbeitsspeicher, Grafikkarte, Netzteil, Festplatte, optisches Laufwerk, Monitor, Tastatur, Maus, Drucker</a></li>
	<li>diese Vorlesung arbeitet von innen nach außen (bottom-up)<ul>
		<li>erst die Basics, dann die „High-Level-Technologien“</li>
	</ul></li>
	<li>erst die Komponenten auf der Hauptplatine</li>
	<li>dann tendenziell Dinge <em>im</em> Gehäuse</li>
	<li>dann tendenziell Dinge <em>außerhalb</em></li>
	<li>Grenze nicht immer eindeutig: es gibt z.B. interne und externe Festplatten</li>
</ul>
</article>

<article class="slide"><h3>Von-Neumann-Architektur (VNA): Überblick</h3>
<ul>
	<li><a href="http://de.wikipedia.org/w/index.php?title=Von-Neumann-Architektur&amp;oldid=123072929">Von-Neumann-Architektur</a>: grundlegendes Modell von 1945, wie ein universeller Rechner aufgebaut werden kann</li>
	<li>beschreibt vier (oder fünf) Komponenten:<ul>
		<li>Hauptprozessor (CPU, Central Processing Unit) mit<ul>
			<li><strong>Rechenwerk</strong> (ALU, Arithmetic/Logic Unit) und</li>
			<li><strong>Steuerwerk</strong> (Control Unit)</li>
		</ul></li>
		<li><strong>Speicherwerk</strong> (Memory Unit, Northbridge)</li>
		<li><strong>Eingabe-/Ausgabewerk</strong> (I/O Unit, Southbridge)</li>
		<li>(evtl. die Datenleitungen dazwischen: das <strong>Bussystem</strong>)</li>
	</ul></li>
</ul>
</article>

<article class="slide"><h3>VNA: Zusammenspiel der Komponenten</h3>
<ul>
	<li>trotz Schwächen basieren fast alle heutigen Computer auf der VNA</li>
	<li>jede Komponente hat ein definiertes Aufgabengebiet</li>
	<li>die VNA ist universell und programmierbar, d.h. was genau der Computer macht, wird durch ein <strong>Programm</strong> beschrieben</li>
	<li>das Programm ist eine Liste von Befehlen, die (genau wie die zu verarbeitenden Daten) im <strong>Arbeitsspeicher</strong> des Computers liegen</li>
	<li>anschaulich im Video <a href="http://www.youtube.com/watch?v=BUCZJWo9MZo">Man &amp; Computer</a> von 1965(!)</li>
</ul>
</article>

<article class="slide"><h3>VNA: Rechenwerk</h3>
<ul>
	<li>die <a href="http://de.wikipedia.org/w/index.php?title=Arithmetisch-logische_Einheit&amp;oldid=121526014">arithmetisch-logische Einheit (ALU)</a> im Rechenwerk rechnet (s. <a href="http://de.wikipedia.org/w/index.php?title=Arithmetik&amp;oldid=122843524">Arithmetik</a>) und führt logische Operationen aus (s. <a href="http://de.wikipedia.org/w/index.php?title=Aussagenlogik&amp;oldid=123199321">Aussagenlogik</a> und <a href="http://de.wikipedia.org/w/index.php?title=Boolesche_Algebra&amp;oldid=121493308">Boolesche Algebra</a>)</li>
	<li>die Operanden erhält das Rechenwerk über die <a href="http://de.wikipedia.org/w/index.php?title=Register_(Computer)&amp;oldid=121044332"><em>Register</em></a> und schreibt Ergebnisse und Statusinformationen auch dorthin wieder zurück, dadurch entsteht die Verbindung zum Steuerwerk</li>
	<li>arithmetische Operationen z.B.: Addition, Subtraktion, Multiplikation</li>
	<li>logische Operationen z.B.: Negation (NOT), Konjunktion (AND), Diskjunktion (OR) und Kontravalenz (XOR)</li>
	<li>(die Vorlesung beschränkt sich auf einfache Ganzzahlarithmetik)</li>
</ul>
</article>

<article class="slide"><h3>VNA: Steuerwerk</h3>
<ul>
	<li>das <a href="http://de.wikipedia.org/w/index.php?title=Steuerwerk&amp;oldid=122434618">Steuerwerk</a> liest und dekodiert Befehle aus dem Arbeitsspeicher</li>
	<li>spricht die zuständige Einheit innerhalb der CPU an und stellt ihr die nötigen Informationen (z.B. Operanden) zur Verfügung</li>
	<li>verwaltet den sog. <a href="http://de.wikipedia.org/w/index.php?title=Befehlsz%C3%A4hler&amp;oldid=116373714">Befehlszähler</a> (Program Counter, PC), der angibt, an welcher Speicherstelle (<em>Adresse</em>) der nächste Befehl steht<ul>
		<li>wird normalerweise nach jedem Befehl auf die Adresse des nächsten gesetzt</li>
		<li><a href="http://de.wikipedia.org/w/index.php?title=Sprunganweisung&amp;oldid=121945524">Sprungbefehle</a> können den PC beliebig verändern, z.B. abhängig von einer Entscheidung der ALU</li>
	</ul></li>
</ul>
</article>

<article class="slide"><h3>VNA: Ein-/Ausgabewerk</h3>
<ul>
	<li>das <a href="http://de.wikipedia.org/w/index.php?title=Eingabe-/Ausgabewerk&amp;oldid=63559750">Ein-/Ausgabewerk</a> stellt die Verbindung zu allen Geräten her, die nicht mehr zu den eng gefassten Komponenten der VNA gehören, der sog. <a href="http://de.wikipedia.org/w/index.php?title=Peripherieger%C3%A4t&amp;oldid=123102612">Peripherie</a></li>
	<li>es beginnt ab der <a href="http://de.wikipedia.org/w/index.php?title=Southbridge&amp;oldid=122697849">Southbridge</a>, dahinter liegen Bussysteme wie SATA, PCIe und USB sowie die daran angeschlossenen Geräte (z.B. Grafikkarte, Festplatte, Tastatur, Drucker)</li>
	<li>auch Dinge, die für Anwender*innen essentiell sind (z.B. Grafikkarte) gehören für die VNA schon zur Peripherie</li>
</ul>
</article>

<article class="slide"><h3>VNA: Speicherwerk</h3>
<ul>
	<li>das <a href="http://de.wikipedia.org/w/index.php?title=Speicherwerk&amp;oldid=105153027">Speicherwerk</a> stellt die Verbindung zum <a href="http://de.wikipedia.org/w/index.php?title=Arbeitsspeicher&amp;oldid=123109249">Arbeitsspeicher (RAM)</a> her</li>
	<li>es beginnt ab der <a href="http://de.wikipedia.org/w/index.php?title=Northbridge&amp;oldid=122697842">Northbridge</a>, dahinter liegen die Speichermodule des Arbeitsspeichers</li>
	<li>Festplatten und andere Massenspeicher sind nicht Aufgabe des Speicherwerkes sondern normale Peripherie; die auf ihnen gespeicherten Daten müssen erst in den RAM transferiert werden, bevor mit ihnen gearbeitet werden kann</li>
</ul>
</article>

<h2>Zahlensysteme</h2>

<article class="slide"><h3>Das Binärsystem</h3>
<ul>
	<li>statt wie im <a href="http://de.wikipedia.org/w/index.php?title=Dezimalsystem&amp;oldid=123040087">Dezimalsystem</a> üblich zehn Ziffern (von 0 bis 9) zu verwenden, gibt es im <a href="http://de.wikipedia.org/w/index.php?title=Dualsystem&amp;oldid=122798693">Binärsystem</a> nur zwei Ziffern: 0 und 1</li>
	<li>lässt sich gut in technischen Systemen abbilden: Strom fließt oder nicht, Loch oder nicht (Lochkarte), in eine Richtung magnetisiert oder die andere (Festplatte), Vertiefung oder nicht (CD) etc.</li>
	<li>verschiedene Möglichkeiten der Markierung als Binärzahl:<ul>
		<li>10111₂ („mit der Basis 2“)</li>
		<li>10111b („Binärzahl“ mit Suffix)</li>
		<li>0b10111 („Binärzahl“ mit Präfix, verwandt mit der Darstellung 027 (Oktalsystem) und 0x17 (Hexadezimalsystem))</li>
	</ul></li>
</ul>
</article>

<article class="slide"><h3>Bits und Bytes</h3>
<ul>
	<li>Computer verwenden binäre Zustände als kleinste Informationseinheit: das <a href="http://de.wikipedia.org/w/index.php?title=Bit&amp;oldid=122590180">Bit</a> ist genau eine Binärziffer, also 0 oder 1</li>
	<li>mit diesen Ziffern rechnet der Computer</li>
	<li>ein <a href="http://de.wikipedia.org/w/index.php?title=Byte&amp;oldid=123068182">Byte</a> oder <em>Oktett</em> ist eine Folge von 8 Bit</li>
	<li>mit einem Bit lassen sich 2 Zustände bzw. Kombinationen, mit zwei Bit 4, mit drei Bit 8, mit vier Bit 16 und mit 8 Bit 256 Zustände darstellen</li>
	<li>ein Byte hat also 256 Kombinationen oder einen Zahlenwert von 0 bis 255</li>
</ul>
</article>

<article class="slide"><h3>Rechnen im Binärsystem</h3>
<ul>
	<li>Addition wie im Dezimalsystem: 0 + 0 = 0, 0 + 1 = 1, 1 + 1 = 10</li>
	<li>Addition zweier Ziffern entspricht (wenn man den Übertrag außer Acht lässt) einem XOR (Kontravalenz)</li>
	<li>Übertrag der Addition zweier Ziffern entspricht einem AND (Konjunktion)</li>
</ul>
</article>

<article class="slide"><h3>Das Hexadezimalsystem</h3>
<ul>
	<li>das <a href="http://de.wikipedia.org/w/index.php?title=Hexadezimalsystem&amp;oldid=122578583">Hexadezimalsystem</a> verwendet 16 Ziffern: die arabischen Ziffern von 0 bis 9 und danach die Buchstaben von a bis f</li>
	<li><em>a</em> entspricht also der 10, <em>f</em> der 15</li>
	<li>Vorteil: zwei Hex-Ziffern haben 16²=256 Kombinationen, können also genau ein Byte darstellen</li>
	<li>verschiedene Möglichkeiten der Markierung als Hexzahl:<ul>
		<li>c4f3₁₆ („mit der Basis 16“)</li>
		<li>c4f3h („Hexadezimalzahl“ mit Suffix)</li>
		<li>0xc4f3 („Hexadezimalzahlzahl“ mit Präfix)</li>
	</ul></li>
</ul>
</article>

<article class="slide"><h3>Rechnen im Hexadezimalsystem</h3>
<ul>
	<li>Addition wieder wie im Dezimalsystem: 2 + 6 = 8, 8 + 5 = d, d + 8 = 15</li>
	<li>Umrechnung von und in Binär ganz einfach, da je 4 Bit einer Hex-Ziffer entsprechen<ul>
		<li>0xd = 0b1101, 0x8 = 0b1000, 0xd8 = 0b11011000</li>
	</ul></li>
</ul>
</article>

<h2>Daten und deren Repräsentation</h2>

<article class="slide"><h3>Zahlen und Buchstaben aus Strom</h3>
<ul>
	<li>ein Computer arbeitet ausschließlich digital: mit den zwei Zuständen 1 und 0 bzw. ›Strom‹ und ›kein Strom‹</li>
	<li>alle Zahlen, Buchstaben, Zeichen, Grafiken, Farben, Töne etc. werden intern als Einsen und Nullen gespeichert und verarbeitet</li>
	<li>wir Menschen bestimmen, wie die Übersetzung funktioniert und welche Rechenregeln es gibt</li>
	<li>›01000001‹ sieht man nicht an, ob es die Zahl 65, der Buchstabe A oder ein 25% deckendes Dunkelrot ist</li>
</ul>
</article>

<h2>Darstellungen von Zahlen</h2>

<article class="slide"><h3>Negative Zahlen</h3>
<ul>
	<li>bei der Umrechnung ins Binärsystem haben wir bislang nur positive Ganzzahlen betrachtet</li>
	<li>für negative Zahlen müssten wir ein „Minus“ voranstellen, also z.B. definieren: steht im ganz linken Bit eine 0, ist die Zahl positiv; steht dort eine 1 negativ</li>
	<li>Zahlenbereich bei 8 Bit dann -127 bis 127</li>
	<li>führt aber zu Problemen: es gibt +0 und -0, außerdem Probleme beim Rechnen (vgl. <a href="http://de.wikipedia.org/w/index.php?title=Einerkomplement&amp;oldid=120010272#Rechenoperationen_und_Probleme">Einerkomplement</a>)</li>
</ul>
</article>

<article class="slide"><h3>Das Zweierkomplement</h3>
<ul>
	<li>das <a href="http://de.wikipedia.org/w/index.php?title=Zweierkomplement&amp;oldid=122283687">Zweierkomplement</a> definiert (für 8-Bit-Zahlen): 0=00000000, 1=00000001 etc., 127=01111111 und dann -128=10000000, -127=10000001, -2=11111110 und -1=11111111</li>
	<li>Umwandlung von Dezimal in Zweierkomplement (Beispiel -22 bei 8 Bit):<ol>
		<li>ohne Vorzeichen in Binärsystem umrechnen: 00010110</li>
		<li>alle Stellen invertieren: 11101001</li>
		<li>1 addieren: 11101010 (entspricht bei Interpretation „vorzeichenbehaftete Ganzzahl im Zweierkomplement“ der -22, bei Interpretation „vorzeichenlose Ganzzahl“ aber der 234)</li>
	</ol></li>
	<li>das Zweierkomplement hat nur eine Darstellung der Null und Vorteile beim Rechnen:</li>
</ul>
</article>

<article class="slide"><h3>Subtraktion mittels Zweierkomplement</h3>
<ul>
	<li>Zahlen im Zweierkomplement sind dergestalt, dass ein „normales“ Addierwerk mit ihnen rechnen kann, ohne zu wissen, dass es negative Zahlen sind!</li>
	<li>Beispiel: 70 - 22, ist äquivalent zu 70 + (-22)</li>
	<li>01000110 + 11101010 = (1)00110000</li>
	<li>lesbar als 70 + 234 = 48 (mit Überlauf, 304 ist nicht in 8 Bit darstellbar)  oder 70 + (-22) = 48 (Überlauf wird ignoriert)</li>
</ul>
</article>

<article class="slide"><h3>mehr als 8 Bit</h3>
<ul>
	<li>Prozessoren können heutzutage mit Zahlen umgehen, die größer sind als 8 Bit</li>
	<li>ein 64-Bit-Prozessor z.B. mit Zahlen, die bis zu 64 Bit groß sind, also ca. ±9,22337204e18</li>
	<li>16 Bit nennt man ein <em>Wort</em> (engl. word), 32 ein <em>Doppelwort</em> (double word), 64 ein Quad-Wort (quad word)</li>
	<li>Prozessoren haben heute meist 32 oder 64 Bit</li>
	<li>für größere Zahlen gibt es Software, die unabhängig von der Arithmetik im Prozessor rechnet</li>
	<li>oder Fließkommazahlen</li>
</ul>
</article>

<article class="slide"><h3>IEEE 754 Floating Point</h3>
<ul>
	<li>Fließkommazahlen werden als Kombination aus Vorzeichen sowie zwei Zahlen (Mantisse und Exponent) gespeichert („wissenschaftliche Schreibweise“, z.B. -2342e-2)</li>
	<li>erlauben die Darstellung sehr kleiner und sehr großer Zahlen, allerdings mit reduzierter Genauigkeit</li>
	<li>bei 32 Bit (<em>single precision</em>): 1 Bit Vorzeichen, 8 Bit Exponent, 23 Bit Mantisse</li>
	<li>rechnen damit ist nicht ganz trivial</li>
	<li>Rundungsfehler können auftreten</li>
</ul>
</article>

<h2>Darstellungen von Zeichen</h2>

<article class="slide"><h3>ASCII</h3>
<ul>
	<li>American Standard Code for Information Interchange</li>
	<li>ordnet den 7-Bit-Zahlen von 0 bis 127 jeweils ein Zeichen zu</li>
	<li>33 „nicht druckbare“ oder „Steuerzeichen“ (z.B. Leerzeichen, Zeilenumbruch, Glocke, Ende des Datensatzes), 95 „druckbare“ Zeichen (lateinische Buchstaben, arabische Ziffern, Interpunktion)</li>
	<li>kennt also 128 Zeichen oder „Codepunkte“</li>
	<li>viele Zeichen fehlen (Umlaute, Sonderzeichen, Symbole, nicht-lateinische Alphabete)</li>
	<li>viele Codepunkte stehen für mehrere ähnlich oder gleich aussehende Zeichen mit unterschiedlicher Semantik, z.B. ›-‹ für Bindestrich und Minus, ›"‹ für Anführungszeichen, Zoll, Sekunde</li>
</ul>
</article>

<article class="slide"><h3>ISO 8859-1 („Latin-1“)</h3>
<ul>
	<li>benutzt 8 Bit, die ersten 128 Zeichen sind identisch zu ASCII</li>
	<li>128–255 enthalten weitere 32 Steuer- und 96 druckbare Zeichen</li>
	<li>Umlaute, kl. Eszett, Cent, Pfund, Yen, Copyright, Paragraph, Guillemets etc., geschütztes Leerzeichen (non-breaking space, NBSP) und bedingter Trennstrich (soft hyphen, SHY)</li>
	<li>beinhaltet natürlich wieder nicht alle Zeichen, sondern nur ein paar mehr</li>
</ul>
</article>

<article class="slide"><h3>ISO 8859-15 („Latin-9“)</h3>
<ul>
	<li>fast identisch mit Latin-1</li>
	<li>8 Zeichen geändert, volle Unterstützung für Französisch, Finnisch und Eurozeichen</li>
	<li>ebenfalls sehr ähnlich: Windows-1252</li>
</ul>
</article>

<article class="slide"><h3>ISO 8859-5 (Kyrillisch), KOI8-R</h3>
<ul>
	<li>für das kyrillische Alphabet gibt es ISO 8859-5 und die verbreiteteren Zeichensätze KOI8-R für Russisch und Bulgarisch sowie KOI8-U für Ukrainisch</li>
	<li>auch diese Zeichensätze setzen auf ASCII auf, beinhalten also das lateinische Alphabet, aber beispielsweise keine deutschen Umlaute</li>
</ul>
</article>

<article class="slide"><h3>Konkurrierende Zeichensätze</h3>
<ul>
	<li>es gibt eine zweistellige Anzahl Zeichensätze, die mehr oder weniger inkompatibel zueinander sind, weil sie an den selben Codepunkten unterschiedliche Zeichen beinhalten</li>
	<li>z.B. steht in Latin-1 an Stelle 228 (0xE4) ein ä, in 8859-5 aber ein ф (Ef) und in KOI8-R ein Д (De)</li>
	<li>man muss also wissen, in welchem Zeichensatz eine Datei verfasst wurde, um sie lesen zu können</li>
	<li>benutzt man den falschen Zeichensatz, entsteht unleserlicher Zeichensalat (jap. <em>mojibake</em>, verformte Buchstaben)</li>
	<li>z.B. »Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства.« als 8859-5 gespeichert, aber als 8859-1 gelesen: »ÈØàÞÚÐï íÛÕÚâàØäØÚÐæØï îÖÝëå ÓãÑÕàÝØÙ ÔÐáâ ÜÞéÝëÙ âÞÛçÞÚ ßÞÔêñÜã áÕÛìáÚÞÓÞ åÞ×ïÙáâÒÐ.«</li>
</ul>
</article>

<article class="slide"><h3>Unicode</h3>
<ul>
	<li>um das Zeichensatzchaos zu beenden, entschloss man sich, einen universellen Zeichensatz (Universal Character Set, UCS) zu definieren</li>
	<li>Ziel: allen Zeichen der Welt einen eindeutigen Codepunkt zuweisen</li>
	<li>ursprünglich dachte man, 65.536 Zeichen (16 Bit) reichen</li>
	<li>inzwischen sind in Unicode 17 Ebenen (Planes) à 65.536 Zeichen vorgesehen, also 1.114.112 Zeichen</li>
	<li>durchnummeriert mit „U+“ gefolgt von Zeichennummer in Hex, (führende) Nullen der Ebenennummer dürfen weggelassen werden: U+0000 bis U+10FFFF</li>
	<li>wird seit 1991 ständig weiterentwickelt und beinhaltet auch Regeln für den Umgang mit den Zeichen (Umbruch, Groß-/Kleinschreibung, Kombination) und Kategorisierungen (Buchstabe, Ziffer, Symbol, Weißraum etc.)</li>
	<li>Nachteil: passt nicht mehr in 8 Bit, nicht mal in 16</li>
</ul>
</article>

<article class="slide"><h3>UTF</h3>
<ul>
	<li>Unicode selbst gibt nur die Codepunkte vor, die Darstellung in Bits und Bytes obliegt den sog. <em>UCS Transformation Formats</em> (UTF)</li>
	<li>man unterscheidet sie nach der Anzahl Bits, die sie mindestens benötigen, um ein Zeichen darzustellen</li>
	<li>die Anzahl Bytes pro Zeichen ist also teilweise variabel</li>
	<li>häufiger vorkommende Zeichen werden mit weniger Bytes dargestellt, seltener vorkommende mit mehr</li>
	<li>das ist recht einfach zu bewerkstelligen, weil sie in Unicode grob nach Häufigkeit sortiert sind: häufige Zeichen kommen früher in der Nummerierung und haben daher eine kleine Codepunkt-Nummer</li>
</ul>
</article>

<article class="slide"><h3>UTF-8</h3>
<ul>
	<li>variable Länge: ein Zeichen wird mit 1–4 Byte dargestellt</li>
	<li>ASCII wird identisch codiert (1 Byte, 0–127, U+0000–U+007F)</li>
	<li>Multi-Byte-Sequenzen haben ein Startbyte (beginnt mit 11) und 1–3 Folgebytes (beginnen mit 10)</li>
	<li>Anzahl Folgebytes ist im Startbyte kodiert: beginnt es mit 110 folgt eins, bei 1110 zwei und bei 11110 drei</li>
	<li>führende Nullen des Codepunkts werden in UTF-8 weggelassen, aber immer auf 7, 11, 16 oder 21 Stellen behalten (ganze Bytegrenze)</li>
	<li>Beispiel an der Tafel</li>
</ul>
</article>

<article class="slide"><h3>UTF-16</h3>
<ul>
	<li>ursprüngliche Idee: feste Länge für alle 65.536 Unicode-Zeichen</li>
	<li>seit Unicode mehr als 65.536 Zeichen hat, ist dieser Vorteil dahin</li>
	<li>UTF-16 benutzt für die Zeichen aus Ebene 0 (Basic Multilingual Plane, BMP) 2 Bytes, für alle anderen 4 Bytes</li>
	<li>seltener eingesetzt als UTF-8, aber von Windows intern häufig verwendet</li>
</ul>
</article>

<article class="slide"><h3>UTF-32</h3>
<ul>
	<li>4 Byte pro Zeichen, daher feste Länge für alle Unicode-Zeichen</li>
	<li>Vorteil: für Software einfacher zu lesen und zu verarbeiten da feste Länge; Anzahl Zeichen direkt aus Anzahl Bytes berechenbar und umgekehrt</li>
	<li>Nachteil: erhöhter Platzbedarf, benötigt z.B. für deutsche Texte fast viermal so viel Speicher</li>
</ul>
</article>

<h2>Massenspeicher</h2>

<article class="slide"><h3>Massenspeicher</h3>
<ul>
	<li><a href="http://de.wikipedia.org/w/index.php?title=Massenspeicher&amp;oldid=118539284">Massenspeicher</a> speichern im Gegensatz zum <a href="http://de.wikipedia.org/w/index.php?title=Arbeitsspeicher&amp;oldid=123468969">Arbeitsspeicher</a> (RAM) Daten permanent und in größerem Umfang</li>
	<li>jedoch weit langsamer als RAM</li>
	<li>Beispiele: Lochkarten, Magnetbänder, Disketten, Festplatten, CD/DVD/BD, USB-Sticks, SD-Karten</li>
	<li>Speicherkapazität inzwischen mehrere Terabyte</li>
</ul>
</article>

<article class="slide"><h3>Binärpräfixe</h3>
<ul>
	<li>Kilo: 10³, Mega: 10⁶, Giga: 10⁹, Tera: 10¹², Peta: 10¹⁵ (jeweils ×1000, „Dezimalpräfixe“)</li>
	<li>in der IT werden gern Zweierpotenzen verwendet, und so wurden sowohl 1000 Byte als auch 1024 Byte „ein Kilobyte“ genannt</li>
	<li>um diese Mehrdeutigkeit loszuwerden, gibt es neue, „<a href="http://de.wikipedia.org/w/index.php?title=Bin%C3%A4rpr%C3%A4fix&amp;oldid=123199738">Binärpräfixe</a>“:</li>
	<li>Kibi: 2¹⁰, Mebi: 2²⁰, Gibi: 2³⁰, Tebi: 2⁴⁰, Pebi: 2⁵⁰ (jeweils ×1024)</li>
	<li>1 Terabyte (TB) = 1.000.000.000.000 Byte = 931,3 Gibibyte</li>
	<li>1 Tebibyte (TiB) = 1.099.511.627.776 Byte</li>
	<li>Verwirrung ist weiterhin tief verwurzelt</li>
</ul>
</article>

<article class="slide"><h3>Festplatte</h3>
<ul>
	<li><a href="http://de.wikipedia.org/w/index.php?title=Festplattenlaufwerk&amp;oldid=123171888">Festplatte</a>: mehrere magnetisierbare runde Scheiben übereinander (magnetische Speicherung)</li>
	<li>konzentrische <em>Spuren</em>, jede enthält mehrere <em>Blöcke</em></li>
	<li>Gesamtheit aller übereinander befindlichen Spuren: <em>Zylinder</em></li>
	<li>Gesamtheit aller Blöcke mit dem selben Winkel („auf dem selben Kuchenstück“): <em>Sektor</em></li>
</ul>
</article>

<article class="slide"><h3>Festplatte</h3>
<ul>
	<li>sich gemeinsam an einer Art „Kamm“ befindliche Schreib-Lese-Köpfe schweben über den Scheiben, einer pro Scheibenseite</li>
	<li>Messgrößen: Spurwechselzeit (Zeit bis Kopf über korrekter Spur), Latenz (Zeit bis korrekter Block am Vorbeirotieren), Datenrate (MB/s, die gelesen werden)</li>
	<li>Gehäuse staub-, aber nicht luftdicht (Druckausgleich, kein Vakuum)</li>
	<li>Videos: <a href="http://www.youtube.com/watch?v=kdmLvl1n82U">Erklärung</a>, <a href="http://www.youtube.com/watch?v=JAVIdoN5Yac">in Aktion</a></li>
</ul>
</article>

<article class="slide"><h3>Compact Disc (CD)</h3>
<ul>
	<li><a href="http://de.wikipedia.org/w/index.php?title=Compact_Disc&amp;oldid=123541976">CD</a>: mit mikroskopischen Vertiefungen („Pits“, Flächen außenrum heißen „Lands“) versehene runde Kunststoffscheiben (optische Speicherung)</li>
	<li>„normale“ 74-Minuten-CD enthält 333.000 Blöcke/Sektoren mit je 2.352 Byte</li>
	<li>Daten-CDs verwenden 304 Bytes pro Block für Redundanz/Fehlerkorrektur, 2.048 Byte übrig, also 650,4 MiB</li>
	<li>bei Musik keine Redundanz: 783.216.000 Byte, bei 44,1 kHz 16 Bit stereo (also 176.400 Byte/s) exakt 74 Minuten</li>
</ul>
</article>

<article class="slide"><h3>Compact Disc (CD)</h3>
<ul>
	<li>Abtastung via Laser von „unten“, reflektiert von aufgebrachter Silberschicht</li>
	<li>Umdrehungsgeschwindigkeit wird als Faktor der Audiorate angegeben: 1× (150 KiB/s), 24× etc.</li>
	<li>Massenherstellung: CDs werden als Abdruck eines Glasmasters gepresst</li>
	<li>Heimherstellung: CD-Brenner brennt Pits in die Kunststoffschicht</li>
</ul>
</article>

<article class="slide"><h3>DVD („Digital Versatile Disc“)</h3>
<ul>
	<li><a href="http://de.wikipedia.org/w/index.php?title=DVD&amp;oldid=123501916">DVD</a>: Aufbau wie CD, aber kleinere Pits und engere Spuren, da Laser kürzere Wellenlänge besitzt, außerdem liegt die Datenschicht jetzt näher am Laser</li>
	<li>daher mehr Kapazität: 4,7 GB (4,37 GiB)</li>
	<li>außerdem als Dual Layer verfügbar: zwei Schichten Daten in der DVD, Laser fokussiert um</li>
	<li>alternativ oder zusätzlich auch Double Side möglich: Daten auf beiden Seiten, Reflexionsschicht in der Mitte</li>
	<li>Geschwindigkeitsfaktor von Laufwerken wieder wie bei CDs, nur dass „1×“ jetzt 1.353 KiB/s entspricht</li>
</ul>
</article>

<article class="slide"><h3>DVD („Digital Versatile Disc“)</h3>
<ul>
	<li>unterschiedliche Standards für Rohmedien für Endverbraucher: DVD-R und DVD+R</li>
	<li>DVD-R: offizielles Konsortium</li>
	<li>DVD+R: konkurrierender Standard, „günstigere“ Lizensierung</li>
	<li>Unterschied für Verbraucher meist unerheblich</li>
	<li>inzwischen meist Kombilaufwerke: DVD±R</li>
	<li>(<a href="http://www.clir.org/pubs/reports/pub121/sec3.html">physischer Aufbau von CDs/DVDs</a>)</li>
</ul>
</article>

<article class="slide"><h3>Blu-ray Disc (BD)</h3>
<ul>
	<li><a href="http://de.wikipedia.org/w/index.php?title=Blu-ray_Disc&amp;oldid=123528728">Blu-ray</a>: noch mal mehr Kapazität durch kürzere Wellenlänge, kleinere Pits, engere Spuren und nähere Datenschicht: 25 GB pro Layer</li>
	<li>2 Layer (50 GB) sind Standard für Filme, es gibt auch Versionen und Experimente mit 3 oder 4 Layern mit teilweise bis zu 200 GB</li>
	<li>Geschwindigkeitsangabe wieder als Faktor, diesmal ist 1× 4,5 MB/s</li>
</ul>
</article>

<article class="slide"><h3>Solid State Drive (SSD)</h3>
<ul>
	<li><a href="http://de.wikipedia.org/w/index.php?title=Solid-State-Drive&amp;oldid=123362580">SSD</a>: elektrische Speicherung auf Halbleitern</li>
	<li>entweder RAM-basiert („RAM-Disk“, verliert ohne Strom sofort alle Daten) oder Flash-basiert</li>
	<li>letzteres versteht die Allgemeinheit unter SSDs, RAM-Disks existieren hauptsächlich für den professionellen Einsatz in Servern etc.</li>
	<li>auch USB-Sticks, SD-Karten etc. sind Flash-SSDs</li>
	<li>keine beweglichen Teile, daher geräuschfrei und sehr robust</li>
	<li>extrem kurze Zugriffszeit im Vergleich zur Festplatte</li>
</ul>
</article>

<article class="slide"><h3>Solid State Drive (SSD)</h3>
<ul>
	<li>teurer pro GB als Festplatten</li>
	<li>Flash-Speicherzellen können nur begrenzt oft beschrieben werden („1–5 Millionen Schreibvorgänge“)</li>
	<li>SSD speichert daher möglichst „gleichmäßig“ auf Zellen verteilt und nicht dort, wo das Betriebssystem angibt</li>
	<li>(SSD „merkt“ sich natürlich diese „Umleitungen“)</li>
	<li>außerdem besitzt sie zum Ausgleich „Reservezellen“ (z.B. noch mal 10% der Speicherkapazität)</li>
</ul>
</article>

<article class="slide"><h3>langfristige Datenspeicherung?</h3>
<ul>
	<li>alle Medien gehen irgendwann kaputt oder verlieren Daten</li>
	<li>Festplatte: „10–30 Jahre“: mechanische Ausfälle, Entmagnetisierung (insbes. bei Hitze)</li>
	<li>optische Medien: „CDs 30–50 Jahre, neuere kürzer“: Ablösung der Reflexionsschicht, Kratzer</li>
	<li>Flashspeicher: „10 Jahre“: elektrische Datenverluste</li>
	<li>generell: keine verlässlichen Zahlen</li>
	<li>wichtige Daten doppelt sichern</li>
	<li>aktiv halten: nicht einfach 5 Jahre in den Schrank legen, sondern umkopieren</li>
</ul>
</article>

<h2>Schnittstellen und Bussysteme</h2>

<article class="slide"><h3>grobe Einordnung</h3>
<ul>
	<li>unter einer <em>Schnittstelle</em> verstehen wir einen Teil oder Punkt eines Systems, der benutzt wird, um mit anderen Systemen oder Komponenten zu kommunizieren bzw. zu interagieren</li>
	<li>alle in diesem Kapitel behandelten Technologien sind dieser Definition nach Schnittstellen</li>
	<li>manche Schnittstellen können nur zur Kommunikation mit genau <em>einer</em> Gegenstelle verwendet werden: wir nennen sie <em>Punkt-zu-Punkt-Schnittstellen</em> (z.B. EIA-232, PS/2)</li>
	<li>andere Schnittstellen erlauben es einer Kette von Teilnehmern, miteinander zu kommunizieren, ohne dass sie sich die Daten gegenseitig aktiv weiterleiten müssen: entweder jeder mit jedem oder alle Teilnehmer der Kette mit einem bestimmten; wir nennen sie <em>Bussysteme</em></li>
	<li>werden die Bits einzeln hintereinander übertragen, spricht man von einer <em>seriellen</em>, bei mehreren Bits (z.B. 1–4 Byte) gleichzeitig von einer <em>parallelen</em> Schnittstelle</li>
</ul>
</article>

<article class="slide"><h3>Punkt-zu-Punkt vs. Bus</h3>
<ul>
	<li>manche Schnittstellen können nur zur Kommunikation mit genau <em>einer</em> Gegenstelle verwendet werden: wir nennen sie <em>Punkt-zu-Punkt-Schnittstellen</em> (z.B. EIA-232, PS/2)</li>
	<li>andere Schnittstellen erlauben es einer Kette von Teilnehmern, miteinander zu kommunizieren, ohne dass sie sich die Daten gegenseitig aktiv weiterleiten müssen: entweder jeder mit jedem oder alle Teilnehmer der Kette mit einem bestimmten; wir nennen sie <em>Bussysteme</em></li>
</ul>
</article>

<article class="slide"><h3>seriell vs. parallel</h3>
<ul>
	<li>werden die Bits einzeln hintereinander übertragen, spricht man von einer <em>seriellen</em> Schnittstelle</li>
	<li>bei mehreren Bits (z.B. 1–4 Byte) gleichzeitig von einer <em>parallelen</em> Schnittstelle</li>
	<li>Schnittstellen können entweder Punkt-zu-Punkt oder als Bus aufgebaut sein</li>
	<li>Schnittstellen können entweder seriell oder parallel aufgebaut sein</li>
</ul>
</article>

<h2>externe Schnittstellen</h2>

<article class="slide"><h3>RS-232 (auch: EIA-232)</h3>
<ul>
	<li>Punkt-zu-Punkt, seriell (<em>die</em> serielle Schnittstelle)</li>
	<li>urspr. 25-poliger, später 9-poliger D-Sub-Stecker</li>
	<li>teils auch als Modular-Stecker („RJ45“, „Westernstecker“) oder ganz anders ausgeführt</li>
	<li>verschiedene Geschwindigkeiten, z.B. 1.200 bit/s, 9.600 bit/s, 57.600 bit/s („56k-Modem“), 115.200 bit/s</li>
	<li>Kabellänge abhängig von Übertragungsdate bis ca. 900 m, eher 2–5 m</li>
	<li>früher: Mäuse, Modems, Direktverbindungen zwischen Rechnern, GPS-Empfänger, Mobiltelefone, …</li>
	<li>heute nahezu ausgestorben, höchstens Bastler (Mikrocontroller)</li>
</ul>
</article>

<article class="slide"><h3>IEEE 1284</h3>
<ul>
	<li>Punkt-zu-Punkt, parallel (<em>die</em> „parallele Schnittstelle“, „Parallelport“, „Centronics-Schnittstelle“)</li>
	<li>36-poliger „Centronics“-Stecker und/oder 25-poliger D-Sub-Stecker</li>
	<li>Übertragung eines ganzen Byte auf einmal</li>
	<li>div. Modi, z.B. für bidirektionale Kommunikation</li>
	<li>übliche Geschwindigkeiten: 150 kb/s, 2 MB/s (EPP), 2,5 MB/s (ECP)</li>
	<li>Kabellänge 6–12 m, mit Spezialkabeln bis 30 m</li>
</ul>
</article>

<article class="slide"><h3>PS/2</h3>
<ul>
	<li>Punkt-zu-Punkt, seriell</li>
	<li>6-poliger Mini-DIN-Stecker</li>
	<li>für Tastatur (violett) und Maus (grün)</li>
	<li>es gibt auch Universalbuchsen (v.a. an Laptops), die das angeschlossene Gerät erkennen</li>
	<li>„Adapter“ PS/2-zu-USB meist nur elektrische Verbinder, Tastatur/Maus muss PS/2 <em>und</em> USB beherrschen</li>
	<li>nicht hotplug-fähig (Beschädigungen möglich!)</li>
</ul>
</article>

<article class="slide"><h3>Universal Serial Bus (USB)</h3>
<ul>
	<li>Bus, seriell</li>
	<li>Stecker je nach „Ende“ unterschiedlich: am Host Typ A, am Gerät Typ B</li>
	<li>1.0 (1995), 1.1 (1998): 1,5 Mbit (Low Speed), 12 Mbit (Full Speed), 5 V, 100/500 mA</li>
	<li>2.0 (2000): 480 Mbit (Hi-Speed)</li>
	<li>3.0 (2008): 4000 Mbit (SuperSpeed), 900 mA, neue Kabel/Stecker</li>
	<li>Kabel max. 5 m (Low Speed) bzw. 3 m (Full/Hi-Speed)</li>
</ul>
</article>

<article class="slide"><h3>Universal Serial Bus (USB)</h3>
<ul>
	<li>Hubs sorgen für mehr Ports (max. 127 Geräte), Stromversorgung entweder über den Host (bus-powered) oder ein eigenes Netzteil (self-powered)</li>
	<li>USB ist hotplugfähig</li>
	<li>generische Treiber für Geräteklassen bereits im Standard, spezifische Treiber daher meist überflüssig</li>
	<li>z.B. Massenspeicher, Audio, HID (Human Interface Device, also Tastatur/Maus etc.)</li>
	<li>der Computer (Host) ist verantwortlich für Steuerung, Adresszuteilung etc.</li>
	<li>USB On-The-Go: Geräte implementieren Host-Funktionalitäten, z.B. damit Mobiltelefon Fotos von Digitalkamera laden kann</li>
</ul>
</article>

<article class="slide"><h3>IEEE 1394 („FireWire“)</h3>
<ul>
	<li>Bus, seriell</li>
	<li>ähnlich USB, früher begonnen (1980er), etwa gleichzeitig fertiggestellt</li>
	<li>1394a („FireWire 400“), 1995: 100/200/400 Mbit, 8–30 V, 1500 mA</li>
	<li>sechspolige Stecker: 4 Datenleitungen, 2 Spannungsversorgung; vierpolige (kleine) Stecker ohne Spannungsversorung</li>
	<li>1394b („FireWire 800“), 2002: 800 Mbit, neue Kabel/Stecker (neunpolig, „beta“)</li>
	<li>FireWire 3200, 2008: 3200 Mbit, Geräteangebot eher mau</li>
	<li>Kabel max. 4,5 m (400), mit 1394b auch länger (&gt; 100 m) möglich (bei reduzierter Geschwindigkeit)</li>
	<li>Geräteketten möglich („daisy chaining“)</li>
	<li>kein Host nötig</li>
</ul>
</article>

<article class="slide"><h3>Thunderbolt</h3>
<ul>
	<li>Bus, seriell</li>
	<li>erste Geräte 2011, kombiniert DisplayPort und PCI Express</li>
	<li>20-poliger Mini-DisplayPort-Stecker, 10 Watt</li>
	<li>ursprünglich als optisches Interface gedacht (auch noch in Planung)</li>
	<li>4 Kanäle mit je 10 Gbit pro Sekunde und Richtung, ergo 20 Gbit vollduplex</li>
	<li>Daisychaining von bis zu 7 Geräten, davon max. 2 (HD-)Displays</li>
	<li>abwärtskompatibel zu DisplayPort, dafür muss DisplayPort-Gerät aber am Ende der Kette liegen</li>
	<li>Storage-Geräte, z.B. Festplatten (300 MB/s) bereits erhältlich</li>
</ul>
</article>

<h2>interne Schnittstellen</h2>

<article class="slide"><h3>PATA/IDE (ATA/ATAPI)</h3>
<ul>
	<li>Advanced Technology Attachment: Protokoll für Kommunikation zw. Computer und Massenspeichern</li>
	<li>Integrated Device Electronics: Stecker-/Kabelstandard für gehäuseinterne Verkabelung</li>
	<li>Bus, parallel, 40-poliges Flachbandkabel, 16 Bit, zwei Geräte (Master/Slave) an einem Kabel</li>
	<li>1989 ATA-1 (8,3 MB/s), 1994 ATA-2 (16,6 MB/s), 1996 ATA-3 (S.M.A.R.T.)</li>
	<li>1994 ATA/ATAPI-4 (Unterstützung für CD-ROM und Brenner, Erweiterung um SCSI-Kommandos via „Packet Interface“)</li>
	<li>seit ATA/ATAPI-7 (2001) 133 MB/s, außerdem kam SATA hinzu (selbe Kommandos, aber serielle Übertragung), alte parallele Variante wird jetzt PATA genannt</li>
	<li>Strom über 4-poligen Molexstecker</li>
</ul>
</article>

<article class="slide"><h3>Serial ATA (SATA)</h3>
<ul>
	<li>seriell, Punkt-zu-Punkt (nur noch ein Gerät pro Kabel)</li>
	<li>7-poliges Flachbandkabel, max. 1 m</li>
	<li>Strom über 15-poligen Stecker</li>
	<li>2002 SATA 1.5 Gbit/s („SATA I“): 150 MB/s</li>
	<li>2005 SATA 3.0 Gbit/s („SATA II“): 300 MB/s, außerdem neu: externes SATA (eSATA, außerhalb des PC-Gehäuses)</li>
	<li>2009 SATA 6.0 Gbit/s („SATA III“): 600 MB/s, vorrangig für SSDs (magn. Festplatten sind zu langsam)</li>
	<li>eSATA: für externen Einsatz optimierte Kabel (max. 2 m) und Stecker</li>
	<li>leider noch kein einheitlicher Standard für eSATA-Strom</li>
</ul>
</article>

<article class="slide"><h3>PCI</h3>
<ul>
	<li>Peripheral Component Interconnect</li>
	<li>Busstandard für Erweiterungskarten auf dem Mainboard</li>
	<li>ca. 1993, löste ISA ab</li>
	<li>32-Bit-, später 64-Bit-Parallelbus</li>
	<li>133 MB/s bis 533 MB/s, je nach Version</li>
	<li>25 W pro Steckplatz, hotplugfähig</li>
	<li>für Grafikkarten ergänzt durch AGP, später abgelöst durch PCIe</li>
</ul>
</article>

<article class="slide"><h3>AGP</h3>
<ul>
	<li>Accelerated Graphics Port</li>
	<li>direkte parallele Verbindung der Grafikkarte zum Chipsatz, statt über den PCI-Bus zu gehen</li>
	<li>ca. 1998, Ergänzung zu PCI</li>
	<li>höhere Datenrate (266 bzw. 533 MB/s) und Möglichkeit, System-RAM mitzunutzen (damit Grafikkarte günstiger wird)</li>
	<li>mehrere Ausbaustufen, ab 2002 dann AGP 8x (2.133 MB/s)</li>
	<li>25 W am Steckplatz, viele Grafikkarten benutzen zusätzliche Stromversorgung, z.B. über Laufwerks-Molexstecker</li>
</ul>
</article>

<article class="slide"><h3>PCI Express (PCIe)</h3>
<ul>
	<li>serieller Bus für Erweiterungssteckkarten</li>
	<li>löst ab ca. 2004 PCI und AGP ab</li>
	<li>je nach Version 250, 500 oder 985 MB pro Sekunde und Lane („Spur“)</li>
	<li>Geräte können mit einer oder mehreren (bis zu 16) Lanes angebunden sein, Slots unterschiedlich lang</li>
	<li>16 Lanes PCIe 3.0: 16 × 985 MB/s = 31,5 GB/s</li>
	<li>25 W pro Steckplatz, an PEG-Slots (PCI Express for Graphics, ×16) 75 W</li>
	<li>zusätzliche Stromstecker definiert, die weitere 75 oder 150 W liefern</li>
</ul>
</article>

<article class="slide"><h3>Warum seriell statt parallel?</h3>
<ul>
	<li>man sollte meinen, parallele Übertragung sei prinzipbedingt achtmal schneller als serielle</li>
	<li>warum sind neuere Stellen dann quasi alle seriell?</li>
	<li>parallele Übertragung ist natürlich in der Tat eigentlich schneller</li>
	<li>ab einer gewissen Taktrate wird es jedoch unmöglich, alle Bits gleichzeitig/synchron beim Empfänger ankommen zu lassen</li>
	<li>allein die verschieden langen Leitungswege zwischen z.B. linker und rechter Seite des Steckers machen enorme Probleme</li>
	<li>dazu kommt, dass die Leitungen sich gegenseitig stören („Crosstalk“)</li>
	<li>Taktrate inzwischen so hoch, dass seriell weit schneller ist</li>
</ul>
</article>

<h2>Ethernet</h2>

<article class="slide"><h3>Ethernet (IEEE 802.3)</h3>
<ul>
	<li>Standard zur LAN-Kommunikation zwischen Computern</li>
	<li>LAN: Local Area Network (lokales, also örtlich begrenztes, Netzwerk; z.B. in einer Wohnung oder einem Gebäude)</li>
	<li>definiert elektrische/physikalische Spezifikationen (Leitungsarten, Spannungen, Übertragung von Bits), Struktur der Datenpakete in einem Ethernet-Netz und Aufbau eines solchen</li>
</ul>
</article>

<article class="slide"><h3>Ethernet: Geschichte</h3>
<ul>
	<li>erste Version 1980</li>
	<li>ursprünglich über Koaxialkabel (10BASE2, genannt ›cheapernet‹ oder ›thin ethernet‹, und 10BASE5, ›thick ethernet‹) auf gemeinsamen Leitungen, 10 Mbit/s</li>
	<li>gemeinsame Leitung, also Bus</li>
	<li>aber kein Gerät, das den Bus steuert</li>
	<li>Teilnehmer müssen also zusammenarbeiten, da immer nur einer gleichzeitig senden kann</li>
	<li>Master bestimmen, der dann Sendeerlaubnis erteilt?</li>
	<li>zu aufwendig und Zeit verschwendend</li>
</ul>
</article>

<article class="slide"><h3>CSMA/CD</h3>
<ul>
	<li>Carrier Sense Multiple Access with Collision Detection</li>
	<li>vor dem Senden wird darauf gewartet, dass die Leitung frei ist</li>
	<li>carrier sense: während ein Teilnehmer sendet, „hört“ er gleichzeitig auf die Leitung, ob noch jemand anders sendet</li>
	<li>wenn ja, Senden sofort abbrechen</li>
	<li>anderer Sender tut das selbe</li>
	<li>nach zufälliger Wartezeit Übertragung erneut versuchen</li>
	<li>ähnelt stark dem Verhalten einer Gruppe Menschen auf einer Party</li>
</ul>
</article>

<article class="slide"><h3>Stern- statt Bustopologie</h3>
<ul>
	<li>Busleitungen sind aufwendig und fehleranfällig</li>
	<li>z.B. muss bei Kabelbruch erst aufwendig die Fehlerstelle gesucht werden</li>
	<li>deshalb: Baum-/Sterntopologie über Twisted-Pair-Kabel mit 8P8C-(„RJ45“)-Steckern (10BASE-T)</li>
	<li>Zwischen-/Verteilerstationen: sogenannte Hubs</li>
	<li>von den Hubs gehen Kabel entweder zu Rechnern oder zu anderen Hubs</li>
	<li>Fehlersuche war jetzt einfacher</li>
	<li>jetzt Vollduplex-Übertragung möglich</li>
	<li>Performance weiterhin suboptimal, da alle Pakete an alle Empfänger gingen</li>
</ul>
</article>

<article class="slide"><h3>Switching Hubs</h3>
<ul>
	<li>deshalb (ca. 1990) Hubs um Funktion erweitert, Pakete nur „in Richtung“ Empfänger weiterzuleiten, nicht an alle</li>
	<li>genannt ›Switching Hubs‹ (›umschaltende Hubs‹), kurz ›Switches‹</li>
	<li>merken sich, welche MAC-Adressen an jeden der Anschlüsse (Ports) des Switches verbunden sind</li>
	<li>wenn ein Paket an eine dieser MACs gerichtet ist, wird es nur über den jeweiligen Port weitergeleitet statt über alle</li>
</ul>
</article>

<article class="slide"><h3>aktueller Stand der Technik</h3>
<ul>
	<li>Fast Ethernet (100BASE-TX, 100 Mbit/s, 1995), Gigabit Ethernet (1000BASE-T, 1999)</li>
	<li>aktuell im professionellen Bereich bis zu 100 Gbit/s, u.a. über Glasfaser</li>
	<li>außerdem verfügbar: Power over Ethernet (PoE), bis zu 25 W Stromversorgung</li>
	<li>nützlich für den Anschluss kleiner Geräte (Sensoren, Überwachungskameras etc.) an das Netzwerk, ohne ein zusätzliches Netzteil bzw. eine Steckdose zu benötigen</li>
</ul>
</article>

<article class="slide"><h3>Ethernet-Frames</h3>
<ul>
	<li>Frame: ein Ethernet-Paket, wie es über die Leitung geht</li>
	<li>enthält unter anderem:</li>
	<li>sieben Oktette Präambel (10101010)</li>
	<li>ein Oktett Start of Frame (10101011)</li>
	<li>6 Oktette Ziel-MAC</li>
	<li>6 Oktette Quell-MAC</li>
	<li>42–1500 Oktette Nutzlast</li>
	<li>4 Oktette Prüfsumme (CRC)</li>
	<li>danach 12 Oktette Pause (interframe gap)</li>
</ul>
</article>

<article class="slide"><h3>MAC-Adresse</h3>
<ul>
	<li>Media Access Control address, hat nichts mit Apple zu tun</li>
	<li>„einmalige“ 48-Bit-Adresse einer Netzwerkkarte bzw. eines Netzwerkanschlusses, z.B. 10:9a:dd:a6:d4:6e</li>
	<li>bei handelsüblichen Netzwerkkarten tatsächlich weltweit einmalig (Nummernbereiche pro Hersteller)</li>
	<li>„locally administered addresses“ auch möglich (reservierter Bereich für selbst definierte Adressen)</li>
	<li>MAC-Adresse bestimmt, an welche Netzwerkkarte im Segment das Paket gehen soll</li>
	<li>hat nichts mit dem globalen Routing von Paketen (z.B. im Internet) zu tun</li>
</ul>
</article>

<article class="slide"><h3>Das OSI-Referenzmodell</h3>
<ul>
	<li>sieben Schichten des Netzwerkverkehrs, die aufeinander aufbauen und Komplexität wegabstrahieren</li>
	<li>7: Application (HTTP, SMTP, DNS, DHCP etc.)</li>
	<li>6: Presentation (SSL, TLS)</li>
	<li>5: Session (Sockets, SOCKS)</li>
	<li>4: Transport (TCP, UDP)</li>
	<li>3: Network (IP, ICMP, IPsec)</li>
	<li>2: Data Link (Ethernet-Frames)</li>
	<li>1: Physical (100BASE-TX, 802.11 a/b/g/n, RS-232)</li>
</ul>
</article>

</body>

</html>
